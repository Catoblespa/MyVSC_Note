#include <iostream>
#include <time.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
					
using namespace std;
/*
STL의 알고리즘들은 전역 함수가 처리하며 문제를 풀기 위한 반복 구간, 검색 대상, 채울 밧, 따위의 정보들이 함수의 인수로 전달된다.
알고리즘 함수들은 입력된 정보를 바탕으로 알아서 동작하지만 어떤 함수들은 내부에서 모든 동작을 다 처리하지 않거나 할 수 없는 경우도 있다.
검색하고자 하는 밧이 정확하게 어떤 조건인지, 정렬을 위해 요소를 비교할 때 어떤 방식으로 비교할 것인지를 함수가 마음대로 결정할 수 없다

이때 함수에게 좀더 구체적인 처리 방식을 지정하기위해 사용자정의함수를 함수포인터로 호출하여 의사를 결정한다
마치 표준 qsort함수가 정렬을 위한 비교를 위해 사용자 정의 함수를 함수포인터로호출하는것과 같다.

똑같은 함수를 호출하더라도 함수 객체를 어떻게 작성하는가에 따라 알고리즘의 활용도가 대폭 향상되는 효과가있다.

앞의 예제엣 벡터를 정렬한후 그결과를 확인하기 위해 직접 순회하면서 벡터의 요소를 일일이 출력했었다.
컨테이너의 요소들을 순회하면서 출력이나 비교, 변환 등을 할 일은 아주 흔한데 이때마다 직접 순회를 하려면 반복자도 선언해야하고,
for루프도 구성해야 하므로 다소 번거롭다. for_each함수를 사용하면 순회를 대신 시킬 수 있으며 이때 순회 중에 어떤 작업을 할 것인가를 함수 객체로 지정한다.

for_each 함수의 원형은 다음과 같다

///	 UniOp for_each(Init first, Init last, UniOp op);

for_each ㅎ마수는 first~last 사이를 순회함녀서 각 요소에 대해 op함수 객체를 호출하여 사용자가 이 요소를 직접 처리하도록 한다.
순회는 for_each가 대신 하되 순회중에 각 요소에 대한 고유한 작업은 함수 객체가 처리하는 방식이다.

*/
void print(int a)			//for_each에 전달하기 위해 만든 함수
{
	printf("%d\n", a);
}

//함수가 아닌 '함수 객체' 즉, function Object 또는 Functor를 만들고,
//for_each에 전달해보자.
struct print2 {
	void operator()(int a) const {
		printf("%d\n", a);
	}
};

struct print3 {
private :
	string  mes;

	print3(string &_mes) : mes( _mes) {}
	void operator()(int a) const
	{
		cout << mes << a << endl;
	}
};

struct accum {
	int sum;
	string mes;
	accum() { sum = 0; }

	void operator()(int a)
	{
		cout << mes;
		sum += a;
	}

};


int main()
{

	int ari[] = { 2,8,5,1,9 };
	vector<int> vi(&ari[0], &ari[5]);

	sort(vi.begin(), vi.end());
	for_each(vi.begin(), vi.end(),print);	//for_each에 print함수 주소 전달
											//여기서 세번째 인수에서 전달되는 대상을 함수객체(function Object), 또는 펑터(Functor)라고한다.
											//for_each에서 반복자가 print에게 각 요소를 순회하면서 전달하고, print는 그 요소를 a로받아 출력한다.
											//qsort함수가 비교함수의 포인터를 전달받는 방식과 완전 동일하다.
											//단, STL의 함수 객체는 함수 포인터에만 국한되지 않고,함수를 흉내낼 수 있는 모든 객체일 수 있다.
											//함수 객체는 함수 호출 연산자인()를 오버로딩한 객체를 의미하는데, 이연산자를 통해 마치 함수를 호출하듯이 객체를 호출 할 수 있다.

	for_each(vi.begin(), vi.end(), print2());	//print2 구조체는 () 연산자를 정수값 하나를 인수로 받아 그 값을 출력하도록 오버로딩 하고있다.
												//왜 class가 아니고 struct로 선언했냐 하면, 다음 줄과 똑같은 뜻이기 때문이다.
	print2 f;									//print2 타입 객체 f를 생성한후 이객체를 foreach의 세번째 인수로 전달했다.
	for_each(vi.begin(), vi.end(), f);			//foreach함수는 순회중에 f의 ()연산자를 호출하여 원하는 작업을 할 것이다.
												//이 콛의 함수 객체 f는 for_each의 인수로만 사용하므로 굳이 이름을 주고 지역 객체로 선언할필요가 없다.
												//그래서 함수 호출문에서 곧바로 print2의 디폴트 생성자를 호출하여 임시 객체를 만들고 그 객체를 전달하도록 하는 것이다.
												//그러므로 이 예제의 print2()문은 객체를 호출하는 것이 아니라 print2클래스의 임시 객체를 생성하는 문장임을 알아라.

	//foreach는 반복자 순서에 맞게 순회할 뿐이며, 실제 작업은 함수 객체가한다. 순회중에 어떤 일을 할 것인가는 함수 객체가 인수로 전달받은 요소에 대해 무슨일을 하는가에 따라 달라진다.
	
	/*
	함수 객체는 클래스안에 함수를 캡슐화해 놓은 것으로 함수 포인터에 대한일반화라고 할 수 있다.
	그렇다면 STL은 왜 함수 객체라는 것을 사용할까 ?
	 함수 실행 중에 사용자가 개입할 수 있는 장치로 함수 객체 이전에 함수 포인터라는 더 간단하고 직관적인 방법이 존재했었으며, 문제없이 작동했다.
	 STL이 함수 포인터를 확장하여 함수 객체라는 더 일반화된 개념을 사용하는 이뉴는 함수 포인터에 비해 몇가지 장점이 있고 더 유연하기 때문이다.
		1. 함수 객체는 인라인이 간ㅇ해서 처리 속도를 대폭적으로 개선할 수있다
				-클래스의 내부에서 선언된 맴버 함수는 자동으로 인라인이 되며 호출부에 본체의 코드가 직접 삽입된다. 
				그래서 함수 호출에 대한 부담이 전혀 없으며 알고리즘 처리가 빠르다. 표준 qsort 함수는 매번 비교함수를 호출 해야 하며 정렬 작업보다 함수를
				호출하는데 더 많은 시간을 소비하 때문에 직접 만든 정렬 루틴보다 속도가 훨씬 더 느리다.

				앞의 두 예제도 벡터의 크기를 크게 확장하고 정밀하게 측정해 보면 심각할 정도로 속도차이가 현격하다.
				-함수 포인터는 번지를 통해 호출되므로 호출부에 직접 삽입되는 인라인이 될 수 없으며 매번 스택 프레임을 구성하고
				호출한 후 다시 리턴해야한다. 반면 함수 객체는 인라인이 가능함으로 인해 속도상의 불익이 전혀없다.
				STL이 일반화를 하면서도 효율의 희생이 없다는 장점은 컴파일 타임 메커니즘과 인라인화에 의해 얻어진다.

		2. 함수 객체는 말 그대로 객체이기 때문에 함수 연산자()뿐만 아니라 처리에 필요한 맴버들을 추가로 더 가질수도 있다.
				-연산중에 필요한 변수가 있으면 맴버로 만들 수 있고 필요한 동작이 있다면 멤버 함수도 가질 수 있다.


		*/

	accum af;
	af = for_each(vi.begin(), vi.end(), af);	//for_each 세번째 항에 있는 af는 값만 전달할뿐, 객체 af에 대한 수정하지 않는다.
												//객체 af원본의 값을 변경하기 위해서는 대입해주어야 한다.
												//af가 갖는 operator()(int a)만 가져다 실행했기 때문이다.
	printf("총합 = %d \n", af.sum);				//함수객체를 사용하면 계산후 af에 저장 해놓 을 수도 있으며, 중간 처리값도 구해서 저장할 수있다.
												//일반 함수는 정적변수로 값을 저장 할 수있지만, 그 값을 외부에서 사용 할 수는 없다.
												//또한 한수 객체의 맴버를 ㅁ미리 변경해 놓는 방법으로 알고리즘의 정밀한 세부 동작을 통제 할 수있다.
												//세번째로 맴버 뿐만 아니라 맴버 함수도 가질 수 있으며 생성자와 파괴자도 활용 가능하다.
												//특히 생성자는 맴버의 값을 원하는대로 초기화 할 수 있다는 점에서 함수 객체에 대해서도 여전히 실용성이 높다


	//for_each(vi.begin(), vi.end(), print3(string("합은 : ")));  이건 안되나 보오.
	//for (auto& i : vi)
	//{
	//}

	//for (int it : vi)
	//{
	//}

	return 0;
}