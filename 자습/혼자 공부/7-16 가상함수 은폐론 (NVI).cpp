// ConsoleApplication2.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"

/*
가상함수 은폐론
가상함수는 반드시 private 맴버로 두어야 한다고 주장하는 것.
*/

/*
helathValue를 public 맴버 함수로 그대로 두되 비가상 함수로 선언하고,
내부적으로는 실제 동작을 맡은 private 가상함수를 호출하는 식으로 만들어보자
가상함수의 이름은 적당하게 doHealtValue으로..

*/
class GameCharacter_v1
{
public:
	int healtValue() const
	{
		//사전 동작
		int retVal = doHealtValue();
		//사후 동작
		return retVal;
	}


private:
	virtual int doHealtValue() const
	{
		return 100;
	}
};
/*
위의 코드가 가장 기본적인 설계이다.
사용자로 하여금 public 비가상 맴버 함수를 통해 private가상함수를
간접적으로 호출하게 만드는 방법으로,
비가상 함수 인터페이스(Non-Interface: NVI) 관용구라고 알려져있다.
위의 방식은 NVI를 고전적인 C++의 형태로 구현한것이다.

effective c++ 필자는 이를 가상함수의 랩퍼(wrapper)라고 부른다고한덴다

NVI관용구의 이점은 주석으로 써둔 사전동작과 사후동작이 전부이다.
가상함수가 호출되기 전에 어떤 상태를 구성하고, 가상함수가 호출된 후에
그 상태를 없애는 작업이 랩퍼를 통해 공간적으로 보장된다는 뜻이다.

뮤텍스잠금을 건다던지.. 로그 정보를 만든다던지!! 
클래스의 불변속성과 함수의 사전조건이 만족 되었나 검증하는
작업 등이 "사전 동작" 에 들어갈 수있다.
"사후 동작" 으로는 뮤텍스 잠금을 푼다던지, 사후 조건을 점검하고
클래스의 불변속성을 재검증하는 작업등이 있을 수있다.

일케하면 가상함수의 동작정의는 파생 클래스가 권한을 갖게 되고.
동작 시점은 기반 클래스만의 고유 권한이 된다.

물론 파생클래스에서 healtValue을 재정의 하는 병신짓따윈 하면 안된다..
healtValue함수는 virtual함수로 선언한것이 아니기 떄문에
이 함수는 파생클래스에서도 그대로 쓸거임...!!! 이라고 프로그래머가
강하게 피력한것인데, 그걸 오버로딩해서 네임을 가려버리면.... 병신이다 걍

만약 doHealtValue 가상함수가 외부에서 불릴일이 없고,
파생클래스에서 재정의만 하게 해두는 함수라면 protected로 해야함.
*/

int main()
{
    return 0;
}

