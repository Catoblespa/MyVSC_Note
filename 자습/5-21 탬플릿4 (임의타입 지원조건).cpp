#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <math.h>

using namespace std;
/*
	임의 타입 지원 조건

	함수 템플릿의 본체 코드는 임의의 타입에 대해서도 동일하게 동작해야 하므로 타입에 종속적인 코드는 사용할 수 없다. 
	기본 타입에 대해 이미 오버로딩되어 있는 +, - 등의 연산자를 사용하거나 cout과 같이 피연산자의 타입을 스스로 판별할 수 있는 코드만 사용해야 한다. 
	printf 함수처럼 타입에 따라 서식을 미리 결정해야 하는 함수는 함수 템플릿에서 쓰지 않는 것이 바람직하다. 
	다음 함수를 보자.

template <typename T>
void PrintValue(T value)			//이함수의 경우 value는 어떤 타입의 값이 올지 알 수 없다.
{									//하지만 printf가 %d를 사용하고 있기 때문에, 실질적으로 정수타입의 value만을 올바르게 표시 할 수 있다.
									//만약 다른 타입의 value가 올경우 printf는 지멋대로 출력해버릴 것이다.
	printf("value is %d\n",value);	//이러한 코드는 cout 으로 대체하면 간단히 해결 할 수 있다.

}
*/


struct S 
{
	int i;
	S(int ai) : i(ai) { }
	bool operator>(S &Other) { return this->i > Other.i; }
	//비교 연산자를 오버로딩 해놓지않으면 다음 컴파일 에러 발생.
	// 오류) 이항 '>': 'T'이(가) 이 연산자를 정의하지 않거나 미리 정의된 연산자에 허용되는 형식으로의 변환을 정의하지 않습니다.

};


//컴파일러는 구체화된 템플릿 함수에 대해서만 에러 체크를 할 뿐이지 템플릿 자체에 대해서는 상세한 점검을 할 수 없다. 
template <typename T>
T Max(T a, T b)
{

	return (a > b) ? a : b;
}

int main()
{

	int i1 = 3, i2 = 4;
	double d1 = 1.2, d2 = 3.4;
	S s1(1), s2(2);

	Max(i1, i2);
	Max(d1, d2);
	Max(s1, s2);		
	
						//Max는 두 값 중 큰 값을 리턴하는데 정수나 실수에 대해서는 잘 동작한다. 
						//그러나 구조체 S에 대해서는 동작하지 않는데 구조체끼리는 > 연산자로 비교할 수 없기 때문이다. 
						// 구조체에 > 연산자를 오버로딩해 놓으면 이때는 S객체끼리 대소 비교가 가능해 지므로 Max(s1, s2) 호출도 잘 컴파일된다



	//	템플릿은 인수로 전달된 임의의 타입에 대해 동작할 수 있는 함수의 형틀이지만 
	//그 본체에서는 전달될만한 타입을 모두 지원하는 범용적인 코드만 작성해야 한다.
	//또는 템플릿으로 전달된 타입이 해당 템플릿의 본체 코드의 요구 조건을 모두 만족해야 한다.
	
	//그렇지 않을 경우 잘 사용하던 템플릿도 특정 타입에 대해 구체화했을 때 갑자기 에러가 발생할 수도 있다.

	//http://soen.kr/lecture/ccpp/cpp3/31-1-4.htm 두번째 예제도 있음.


	return 0;	
}
