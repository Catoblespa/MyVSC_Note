#include <iostream>
#include <time.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include <functional>		
#include <iterator>		//여러 종류의 반복자의 정의 담음.

using namespace std;

template<typename C> void dump(const char* desc, C c) {
	cout.width(12); cout << left << desc << "==> ";
	copy(c.begin(), c.end(), ostream_iterator<typename C::value_type>(cout, " ")); cout << endl;
}
/*
///!대입//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
벡터끼리 대입할 때는 간단하게 = 연산자를 사용하면 된다. 
대입을 받는 좌변 벡터는 우변 벡터의 크기만큼 자동으로 크기가 늘어날 것이며 우변의 모든 요소가 좌변으로 대입된다.

대입 연산자는 두 벡터를 완전히 똑같이 만드는데 만약 일부 구간만 복사하고 싶다면 assign 멤버 함수를 사용한다. 
항상 이런 식인데 연산자는 전체에 대한 처리를 하며 일부분에 대한 처리는 별도의 멤버 함수가 준비되어 있다. 
연산자는 전달받을 수 있는 피연산자 수가 제한되어 있어 부분에 대한 처리를 할만큼 충분한 정보를 제공받을 수 없기 때문이다. assign은 다음 두 개의 버전이 제공된다.

		//void assign(size_type count, const Type& val);
		//void assign(InIt first, InIt last);

첫 번째 버전은 val값 count개를 반복적으로 복사한다. 벡터를 특정값으로 가득 채우고 싶을 때 이 버전을 사용한다.
두 번째 버전은 반복자 구간을 받아들이는데 다른 컨테이너의 일부 요소를 벡터에 대입한다. 
템플릿 함수로 정의되어 있으므로 입력 반복자 조건만 만족하면 벡터가 아닌 컨테이너의 구간도 대입할 수 있다.



		
///!교환//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
swap멤버 함수는 두 벡터의 요소들을 통째로 교환한다. 
교환하고자하는 대상 벡터를 인수로 전달하기만 하면 호출한 벡터와 인수로 전달된 벡터가 교환된다.

		//void swap(vector& Right);

멤버 함수 외에 모든 컨테이너에 대해 쓸 수 있는 일반적인 swap 알고리즘도 있다. 벡터끼리 교환하고 싶을 때는 다음 두 가지 방법 중 하나를 사용한다.

		//v1.swap(v2);     // 멤버 함수
		//swap(v1,v2);     // 알고리즘 함수

일반적인 알고리즘이 있는데도 불구하고 벡터가 특별히 swap 멤버 함수를 제공하는 이유는 일반적인 알고리즘이 요소를 직접 교환하도록 되어 있는데 비해 
벡터끼리 교환할 때는 단순히 포인터만 교환하면 훨씬 더 빠르기 때문이다. 
벡터가 요소들을 멤버로 가지고 있는 것이 아니라 내부적으로는 요소의 시작 포인터만을 가지므로 이 포인터와 크기 정보 등만 교환하면 된다.

그러나 실제로 두 개의 swap 함수는 완전히 동등한데 왜냐하면 swap 알고리즘 함수가 벡터에 대해 부분 특수화되어 있기 때문이다. 
swap은 두 개의 컨테이너를 교환하되 벡터나 리스트 등 더 빠르게 교환할 수 있는 컨테이너에 대해서는 멤버 함수 버전을 호출하도록 되어 있다.

		//swap(A,B)	-vector::swap(B);
		//			-list::swap(B);
		//			-deque::swap(B);

즉 전역 swap 함수는 단순히 중계만 할 뿐이며 일관된 방법으로 컨테이너를 교환하는 인터페이스를 제공하는 역할을 한다. 
그래서 어떤 함수를 사용하나 사실상 속도차는 없는 편이다.



///!비교//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
벡터끼리 비교할 때는 ==, != 상등 연산자와 <, >, <=, >= 비교 연산자를 사용한다. 
상등 비교는 요소의 개수와 모든 요소의 값이 일치할 때 같은 것으로 판단한다. 
벡터가 생성되어 있는 메모리 위치나 추가로 할당되어 있는 여유분은 벡터의 실제 내용이 아니므로 상등 비교의 대상이 아니다. 
들어 있는 내용만 같다면 같은 벡터로 취급된다.


대소를 비교할 때는 대응되는 각 요소들을 일대일로 비교하다가 최초로 다른 요소가 발견되었을 때 두 요소의 대소를 비교한 결과를 리턴한다.
만약 한쪽 벡터의 길이가 더 짧아 먼저 끝을 만났다면 아직 끝나지 않은 벡터가 더 큰 것으로 판별한다.


///!요소_참조//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
벡터의 임의 요소를 읽을 때는 [ ] 연산자를 사용하며 괄호안에 부호없는 정수로 첨자를 지정한다. 
벡터는 임의 접근이 가능하므로 첨자 번호로 요소를 빠르게 참조할 수 있다. 
vi 벡터의 크기가 1000일 때 900번째 요소를 읽고 싶다면 vi[900]을 참조하면 된다.
이때 리턴되는 값은 레퍼런스이므로 vi[900]=1234; 처럼 대입식의 좌변에 놓아 요소값을 변경하는 것도 가능하다.

[ ] 연산자와 비슷하게 동작하는 at 함수도 정의되어 있는데 인수로 첨자를 지정한다. 
[ ] 연산자는 첨자가 무조건 유효하다고 가정하는 반면 at 함수는 벡터의 크기를 점검하여 무효한 첨자일 경우 out_of_range 예외를 발생시킨다는 점이 다르다. 
그래서 배열 범위를 벗어나는 실수를 막을 수 있다. 
[ ] 연산자와 at 함수 모두 상수, 비상수 버전이 각각 정의되어 있다.

		//const_reference at(size_type pos) const;
		//reference at(size_type pos);



*/

int main()
{
	// 대입
	cout << "=====대입=====" << endl;
	int ari[] = { 1,2,3,4,5 };
	vector<int> vi(&ari[0], &ari[5]);

	vector<int>vi2;
	vi2 = vi;					//vi을 vi2로 똑같이 복사
	dump("vi2", vi2);

	vector<int>vi3;
	vi3.assign(vi.begin() + 1, vi.end() - 1);		//vi3에 vi의 begin+1 부터 end-1 범위까지만 복사.
	dump("vi3", vi3);





	//복사
	cout << "=====복사=====" << endl;
	const char str[] = "abcdefghijklmnopqrstuvwxyz";

	vector<char> vc1(&str[0], &str[5]);
	vector<char> vc2(&str[5], &str[19]);

	dump("before vc1", vc1);
	dump("before vc2", vc2);

	vc1.swap(vc2);

	dump("after vc1", vc1);
	dump("after vc2", vc2);
	//전역 swap 알고리즘 함수로 벡터를 교환해도 결국은 swap 멤버 함수가 교환을 처리할 것이다. 
	//그러나 두 벡터의 타입이 달라서는 안되는데 vector<int>와 vector<char>는 서로 대입될 수 없는 대상이므로 교환도 불가능하다.





	cout << "=====비교 ======" << endl;

	const char* str2 = "0123456789";

	vector<char> vc4(&str[0], &str[10]);
	vector<char> vc5;
	vector<char> vc6;

	vc5 = vc4;
	puts(vc4 == vc5 ? "같다" : "다르다");
	puts(vc4 == vc6 ? "같다" : "다르다");
	vc5.pop_back();
	puts(vc4 > vc5 ? "vc4가 vc5보다 크다" : "vc4가 vc5보다 크지 않다");
	//연산자는 벡터 전체를 비교하며 일부 구간만 비교하고 싶을 때는 다음 장에서 배울 equal, mismatch 알고리즘 함수를 사용한다.
	//이 함수들을 사용하면 벡터뿐만 아니라 임의의 컨테이너 구간끼리도 비교할 수 있다.




	cout << "===요소참조===" << endl;

	int ari2[] = { 1,2,3,4,5 };\
	vector<int> vi7(&ari[0], &ari[5]);

	try {
		//cout << vi[10] << endl;	//vi[10]은 예외를 일으키지 않고 무조건 10 번째 값을 읽으므로 다운되거나 아니면 운이 좋다 하더라도 쓰레기값을 돌려줄 것이다.
		cout << vi7.at(10) << endl;	// at 함수는 예외를 일으키므로 try 블록안에 넣어두면 안전하게 예외를 처리할 수 있다.
	}
	catch (out_of_range e) {
		cout << "벡터의 범위를 벗어났습니다." << endl;
	}

	//at 함수가 예외를 처리하므로 안전성이 좀 더 높지만 액세스할 때마다 첨자 범위를 일일이 점검해야 하므로 속도는 느리다.
	//예외 처리를 위해 반드시 try, catch 블록을 구성해야 하므로 번거롭기도 하다.
	//일정한 범위에 대해서만 루프를 돌 때는 굳이 at 함수를 쓸 필요없이 [ ] 연산자를 사용하는 것이 더 효율적이다. 

	//용자가 첨자 번호를 직접 입력한다거나 할 때만 at 함수와 예외 처리를 사용하는 것이 좋다. 
	//벡터는 무엇보다 빠른 요소 참조가 장점인데 읽을 때마다 범위를 점검하면 이 장점이 사라질 것이다.
	return 0;
}
