#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <math.h>

using namespace std;

/*
구체화

함수 템플릿은 어디까지나 함수를 만들기 위한 형틀에 지나지 않으며 그 자체가 함수인 것은 아니다.
다. 컴파일러는 함수 템플릿 정의문으로부터 앞으로 만들어질 함수의 모양만 기억하며 실제 함수가 호출될 때 타입에 맞는 함수를 작성한다. 
함수 템플릿으로부터 함수를 만드는 과정을 구체화 또는 인스턴스화(Instantiation)라고 하는데 호출에 의해 구체화되어야만 실제 함수가 만들어진다.

이때 함수 템플릿으로부터 만들어지는 함수를 템플릿 함수라고 한다.
 -함수 템플릿은 함수를 만들기 위한 템플릿이고,
 -템플릿 함수는 템플릿으로부터 만들어지는 함수이다.

 즉 함수 템플릿을 코드로 작성하고, 해당 템플릿을 호출하지 않으면 컴파일러는 해당 템플릿으로 아무것도 만들지 않는다.
 함수 템플릿으로 작성된 템플릿을 사용하여 코딩할경우 컴파일러는 그 인자에 맞는 템플릿 함수를 만들어서 적용한다.


컴파일러에 의해 구체화된 함수는 실행 파일에 실제로 존재하며 컴파일 단계에서 미리 만들어지므로 실행시의 부담은 전혀 없다.
함수가 호출될 때 만들어지는 것이 아니다. 대신 매 타입마다 함수들이 새로 만들어지므로 구체화되는 수만큼 실행 파일의 용량이 늘어난다
 이런 면에서 볼 때 템플릿보다는 오히려 SwapVoid 예제의 방식이 메모리 절약면에서는 유리한데 SwapVoid는 어떤 타입에 대해서건 함수는 딱 하나밖에 생성되지 않는다.
*/


/*
명시적 인수 지정

컴파일러는 호출부의 실인수 타입을 판별하여 필요한 함수를 구체화하는데 예를 들어 Swap(a, b)는 a, b가 정수이므로 Swap(int, int) 함수를 구체화할 것이고
 Swap(c, d)는 c, d가 실수형이므로 Swap(double, double) 함수를 구체화할 것이다
 템플릿 타입 정의에 의해 두 인수의 타입은 같아야 하므로 SwapTemp 예제에서 Swap(a, c)는 두 인수의 타입이 int, double로 달라 에러로 처리된다.
 Swap(a, c) 호출에 대해 Swap(double, double) 함수를 구체화하고 a를 double로 암시적 변환해서 호출할 수도 있을 것 같지만
 템플릿은 타입이 정확해야 하므로 암시적 변환까지는 고려하지 않는다.

 상수는 변수와 달리 그 형태만으로 타입을 정확하게 판단하기 힘든 경우가 있다.

  그래서 템플릿 함수를 호출할 때 실인수와는 다른 타입을 강제로 지정할 수 있는데 이때는 함수명 다음의 < > 괄호안에 원하는 타입을 밝힌다. 
  다음 템플릿 함수는 큰 값을 조사한다.

		template <typename T>
		T Max(T a, T b)
		{
			return (a > b) ? a:b;
		}
Max(3, 4)는 두 인수가 정수형이므로 Max(int, int) 함수를 구체화하여 호출할 것이다. 
그러나 Max<double>(3, 4)로 호출하면 실인수 3, 4가 정수형 상수지만 산술 변환되어 Max(double, double) 함수가 호출된다.
물론 Max(3.0, 4.0)이라고 호출해도 마찬가지이다

리턴 타입이나 인수로 직접 사용되지 않는 타입을 가지는 함수를 호출하기 위해서는 명시적으로 템플릿의 인수 타입을 지정해야 한다.
리턴 타입은 호출할 함수를 결정할 때는 사용되지 않으며 또한 인수로 전달되지 않고 함수 내부에서만 사용하는 타입도 함수 호출문에는 나타나지 않는다.
이럴 때는 컴파일러가 함수 호출문만으로 구체화할 함수를 결정할 수 없으므로 어떤 타입의 템플릿 함수를 원하는지를 분명히 지정해야 한다


*/
//cast는 인수로 전달된 s를 템플릿 인수가 지정하는 타입으로 캐스팅하는 함수이다.

template <typename T>
T cast(int s)			
{
	return (T)s;
}


//func 함수는 내부적인 처리를 위해 T형의 지역변수 v를 선언하여 사용한다. 
//물론 T가 가변적인 타입이므로 본체는 전달된 모든 타입에 대해 가능한 코드만 사용해야 한다

//func는 인수도 리턴값도 없으므로 호출부만 봐서는 도대체 어떤 함수를 구체화할 지 전혀 결정할 수 없다. 
//따라서 func()라고 호출하면 컴파일러는 뭘 원하는지 어리둥절해 할 것이다. 이때도 func<int>() 처럼 지역변수 v의 타입을 명시적으로 전달해야 한다.
template <typename T>
void func(void)
{
	T v;
	cin >> v;
	cout << v;
}


void main()
{
	//unsigned cast(int), double cast(int) 두 버전의 함수가 구체화되는데 이 두 함수는 이름이 동일하고 인수 목록까지 같으므로 오버로딩 조건을 만족하지 못한다. 
	//이처럼 리턴 타입만 다른 경우라도 템플릿에 의해 각각 따로 구체화될 수는 있지만 호출할 때 어떤 함수를 호출하는지를 반드시 밝혀야 한다.
	// cast <Type>(int); 이런식으로 어떤 템플릿 함수를 호출할건지 지정한다. Type의 형식에따라 템플릿함수가 호출된다.

	//unsigned  i = cast<unsigned>(1234); 를 사용한 순간 cast<unsigned>(unsigned)가 구체화 됬다. (확정됬다.)
	unsigned  i = cast<unsigned>(1234);		//1234라는 상수는 cast의 정수형 인수로 고정되어 있을 뿐이지 T를 결정하는데는 사용할 수 없다. 
	double d = cast<double>(5678);

	printf("i=%d, d=%f\n", i, d);

	func<int>();
}


/*

명시적 구체화

함수의 호출부를 보고 컴파일러가 템플릿 함수를 알아서 만드는 것을 암시적 구체화라고 한다.
개발자가 원하는 타입으로 함수를 호출하기만 하면 나머지는 컴파일러가 다 알아서 하며 호출하지 않는 타입에 대해서는 구체화하지 않는다.
만약 특정 타입에 대한 템플릿 함수를 강제로 만들고 싶다면 이때는 명시적 구체화(Explicit Instantiation)를 하는데 
 이는 지정한 타입에 대해 함수를 생성하도록 컴파일러에게 지시하는 것이다.
 예를 들어 float 타입을 교환하는 함수를 생성하고 싶다면 다음 명령을 사용한다.

	template void Swap<float>(float, float);

이 선언에 의해 float형을 인수로 취하는 Swap(float, float) 함수가 만들어진다.
이 함수가 당장 필요치 않더라도 일단 만들어 놓고 싶다면 명시적 구체화로 강제 생성을 지시할 수 있다.
다만 함수의 내용을 숨기고 싶을 때는 함수 템플릿을 공개할 수 없으므로 이럴 때는 명시적 구체화로 자주 사용할만한 타입에 대해 일련의 함수 집합을 미리 생성해 놓는다.
이 라이브러리의 사용자는 개발자가 명시적으로 구체화해 놓은 함수만 사용할 수 있을 것이다. 
명시적 구체화는 컴파일 속도에도 긍정적인 효과가 있는데 미리 필요한 함수를 생성해 놓으면 컴파일러가 어떤 함수를 생성할 것인지를 판단하는 시간을 조금 절약할 수 있다.

*/