#include <iostream>
#include <time.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include <functional>		

using namespace std;


/*
//!반복자란 ?			: //영어 원문으로는 !이터레이터(!iterator)라고 

앞 장에서 간단히 소개했다시피 반복자는 컨테이너의 한 지점을 가리키는 객체이다. 
배열의 첨자나 연결 리스트의 노드 포인터도 이런 역할을 하지만 반복자는 기존의 포인터에 비해 훨씬 더 일반화된 개념이다. 
컨테이너의 종류와 내부 구조에 상관없이 한 요소를 가리키는 목적으로 반복자라는 동일한 장치를 일관된 방법으로 사용할 수 있다.

컨테이너에 대해 어떤 작업을 하고 싶다면 먼저 이 컨테이너에 저장되어 있는 요소에 접근해야 하므로 순회가 꼭 필요하다. 
알고리즘이란 컨테이너 자체에 대해 적용되는 것이 아니라 결국은 컨테이너의 요소들에 적용되는 것이므로 요소를 읽고 쓸 수 있어야 하는데 이를 위해 반복자가 사용된다.

알고리즘은 반복자를 통해 컨테이너의 요소를 읽고 변경하며 컨테이너는 알고리즘을 호출할 때 작업 대상 요소를 반복자로 지정한다. 
그래서 반복자를 알고리즘과 컨테이너를 연결하는 매개체라고 한다.

반복자를 관리하는 기본적인 방법은 ++, --, *, ==, >, < 등의 연산자
요소들이 어떤 모양을 가지든지 * 연산자로 읽을 수 있고 요소들간의 배치 관계에 상관없이 ++만 하면 다음 요소로 이동 가능


//!반복자 !구간 
모든 알고리즘 함수들은 작업 대상을 전달받기 위해 반복자를 인수로 받아들인다. 
특정한 단일 요소에 대해 적용되는 알고리즘은 대상 요소 하나만을 받아들이지만 
대개의 경우는 두 개의 반복자로 표현되는 반복자 구간(iterator range)을 받아들여 구간내의 모든 요소에 대해 적용된다. 
가장 자주 사용되는 find, sort함수의 원형을 보자.


InIt find(InIt first, InIt last, const T& val);
void sort(RanIt first, RanIt last);



둘 다 first, last 두 개씩의 반복자를 받으므로 반복자 구간에 대해 동작한다. 
임의의 값을 찾기 위해서는 검색 범위가 지정되어야 하며 정렬이라는 것도 복수 개의 요소들을 기준에 따라 재배치하는 것이므로 구간이 전달되는 것이 합당하다. 
통상 구간의 시작점은 first라는 이름을 쓰고 끝은 last라는 이름을 쓰는데 first와 last가 지정하는 반복자 구간에 first는 포함되지만 last는 포함되지 않는다.

										   ┌────────────────┐
									-------●----------------○-----
										first			   last
										시작점포함		 끝점 제외

 STL의 세계에서는 범위의 끝은 제외하는 것이 상식이다.
디지탈의 세계에서 범위를 칭하면 항상 끝은 범위에 포함되지 않는 것으로 취급한다.
예를 들어 크기 10의 배열 ar[10]을 0으로 채우는 코드는 보통 다음과 같이 루프를 작성한다.
		//for (i=0; i<10; i++) ar[i]=0;

STL 함수들도 내부적으로 루프를 많이 사용하는데 모두 이런 식으로 작성되어 있다.
STL의 모든 컨테이너는 시작점과 끝다음점을 조사하는 begin, end 멤버 함수를 제공한다. 
끝다음점(past the end)이란 마지막 요소의 다음을 의미하는데 배열의 경우는 배열 크기와 같은 첨자가 될 것이고 연결 리스트의 경우 tail 위치가 될 것이다.
이 지점은 실제 컨테이너의 내부는 아니며 이미 끝을 지난 지점이지만 순회나 에러 처리에 아주 유용하다. 
끝다음점 직전까지만 순회하면 지정한 구간의 모든 요소를 안전하게 방문할 수 있다. find 함수의 구현 코드를 보자.

				//InIt find(InIt first, InIt last, const T& val)
				//{
				//	 for (;first != last; ++first) {
				//		  if (*first == val) break;
				//	 }
				//	 return first;
				//}

first가 계속 증가하면서 컨테이너의 다음으로 이동하는데 조건식이 first != last로 되어 있다. 
따라서 first가 last가 아닌 동안 순회를 반복하며 last에 도달했을 때 루프를 탈출하므로 결국 last는 처리 대상에서 제외된다.
조건식을 first < last로 대소 비교하지 않고 first != last로 부등 비교를 하는 점에 주목하도록 하자.

반복자는 대소 비교를 하지 않고 항상 부등 비교를 하는데 왜 그런가 하면 일반화된 반복자는 대소 비교가 가능하지 않기 때문이다. 
리스트의 반복자는 메모리 여기 저기에 흩어져 있는 노드의 포인터인데 앞쪽 노드가 반드시 앞쪽 번지에 있다고 보장할 수 없다. 
그래서 부등 비교를 할 수밖에 없으며 또한 반복자는 절대 두 칸 이상 이동하지 않으므로 부등 비교를 해도 안전하다. 
만약 last도 처리 대상에 포함된다면 루프는 좀 더 복잡해지고 게다가 에러 처리 방법이 묘연해진다.

				//이건 find원형이아니라 !예시 임
				//InIt find(InIt first, InIt last, const T& val)
				//{
				//	 for (;; ++first) {
				//		  if (*first == val) return first;
				//		  if (first == last) break;
				//	 }
				//	 return ???;
				//}
//즉,
//STL을 쓰는 동안 범위의 규칙을 항상 염두에 두어야 하는데 3번 요소부터 7번 요소까지 검색하고 싶다면 필요한 검색 구간은 3~8까지이다.





*/

int main()
{
    //호에엥 소스 없쪄여
	return 0;
}


/*





*/