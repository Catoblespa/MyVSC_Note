/*

				[파티클 시스템의 드로잉]


파티클 시스템은 동적이기 때문에 매 프레임마다 시스템의 파티클을 갱신해야 한다.
다음은 비효율적이기는 하지만 이해하기 쉬운 파티클 시스템의 한가지 렌더링 방식이다.


[] 최대 수의 파티클을 보관 할 수 있을만한 버텍스 버퍼를 만든다
	각프레임에 다음과 같은 작업을 수행한다.
	A.모든 파티클을 갱신한다.
	B.모든 살아있는 파티클들을 버텍스 버퍼로 복사한다.
	C. 버텍스 버퍼를 그린다.

동작에는 문제가 없지만 이 방식은 그리 효율적이지 못하다.
먼저 버텍스 버퍼가 시스템 내의 모든 파티클을 포함 훌 수 있을 만한 크기를 가져야 한다는 문제가 있다.
하지만 무엇보다 리스트에서 버텍스 버퍼로 모든 파티클을 복사하는 동안 그래픽 카드가 아무일도 하지 않는다는 것이 심각하다(B단계)

예를 들어 우리의 시스템에 10000개의 파티클이 있다고 가정해 보자.
먼저 우리는 10000개의 파티클을 보관할 수 있는 버텍스 버퍼가 필요하며,
이는 분명 상당히 부담되는 크기이다.
게다가 버텍스 버퍼로 10000개의 파티클을 복사하고 DrawPrimitive를 호출하기 전까지
그래픽 카드는 아무런 일도 하지 못한다.
이는 CPU와 그래픽카드가 협력하지 않는 하나의 좋은 예이다.

물론 좀더 나은 방법 (SDK의 포인트 스프라이트 예제에서 이용하는 방법이기도 하다)이 있다.

		[NOTE]
			간단한 설명이긴 하지만 개념을 이해하는데 충분할 것이다.
			이 예에서는 항상 전체 세그먼트를 채울 수 있는 500개의 파티클이 존재한다고 가정하고 있지만,
			실제로는 끊임 없이 파티클이 만들어지고 제거되므로 매 프레임마다 존재하는 파티클의 수는 달라지게 된다.
			
			예를 들어, 현재의 프레임에 복사하고 렌더링할 파티클이 200개라고 가정해보자.
			200개의 파티클로는 세그 먼트를 완전히 채울 수 없으므로 이와 같은 상황을 해결하는 코드가 필요하다.
			이 상황은 현재 프레임의 마지막 세그먼트를 체우는 경우에만 발생한다.
			왜냐하면 마지막 세그먼트가 아닐 경우에는 다음 세그먼트로 이동할 최소한 500개의 파티클이 존재할 것이기 떄문이다.

[]적당한 크기의 버텍스 버퍼(예를 들어 2000개의 파티클을 포함 할 수 있는 크기)를 만들고
이를 세그먼트로 나눈다. 이 예에서는 세그먼트 크기를 500파티클로 지정했다.


					버텍스 버퍼 : 2000 파티크르이 용량
<-------------------------------------------------------------------------------------------------------->
[세그먼트0 : 500파티클 용량][세그먼트1 : 500파티클 용량][세그먼트02 : 500파티클 용량][세그먼트03 : 500파티클 용량]

현재 위치의 세그먼트를 표시하기 위한 전역변수 i=0을 만든다.
각 프레임에 다음과 같은 작업을 수행한다.

	A. 모든 파티클을 갱신한다.
	B. 모든 생존 파티클이 렌더링 될 때까지 :
		1. 만약 버텍스 버퍼가 가득 차지 않았다먄 :
			a. D3DLOCK_NOOVER-WRITE 플래그로 세그먼트 i를 잠근다.
			b. 세그먼트 i로 500파티클을 복사한다.
		2.만약 버텍스 버퍼가 가득 찼다면 :
			a. 버텍스 버퍼의 처음부터 시작한다. i=0 
			b. D3DLOCK_DISCARD 플래그로 세그먼트 i를 잠근다.
			c. 세그먼트 i로 500 파티클을 복사한다.
		3.세그먼터 i를 렌더링한다.
		4.다음 세그먼트로 i++


		[REMARK]
		우리가 이용하는 버텍스 버퍼는 동적으로 운영되므로 
		동적 잠금 프래그인 D3DLOCK_NOOVERWRITE와 D3DOCK_DISCARD의 이점을 황용 할 수 있다.
		이들 플래그는 버텍스 버퍼의 일부가 렌더링될 때 렌더링 되지 않는 일부 버퍼를 잠글 수 있도록 해준다.
		예를 들어 D3DLOCK_NOOVERWRITE 플래그를 이용해 세그먼트 0을 렌더링한다면, 
		세그먼트0이 렌더링 되는 동안 세그먼트 1을 잠그고 채울 수 있다. 이와 같은 방식은 렌더링 지연을 막을 수 있다.


앞서 소개한 방식에 비하면 이방식은 훨씬 높은 효율을 보여준다.
먼저 필요한 버텍스 버퍼의 크기를 줄일 수 있으며, 두번째로 CPU와 그래픽 카드가 함께 작업할 수 있다.
즉, 작은 단위의 파티클들을 버텍스 버퍼로 복사하는 동안 (CPU 작업) 작은 단위의 드로잉을 수행 할 수 있다. (그래픽 카드의 작업)
이어 다음 단계의 파티클을 복사하고 렌더링 할 수 있다. 그래픽 카드가 아무 일도 하지 않고 쉬는 경우는
발하지 않는다.

이제 렌더링 방식의 구현으로 관심을 돌려보자.
이 방식을 이용한 파티클 시스템 렌더링을 위해서는 PSystem 클레스에 다음과 같은 데이터 맴버를 이용해야한다.

.......................................................................................

	[무작위 성]

시스템의 파티클에는 무작위성이 필요하다. 예를 들어 눈을 모델링 한다고 가정할때,
모든 눈송이가 정확하게 동일하게 내리기를 원하지는 않을 것이다.
눈송이가 내리는 비슷해야 하지만 정확히 같아서는 곤란하다.
따라서 파티클 시스템에 필요한 무작위성을 지원하기 위해 다음과 같은 두 개의 함수를 추가하였다.


첫번째 함수는 LowBound , HighBound 범위에 있는 임의의 float을 리턴한다.

	float GetRandomFloat(float lowBound , float highBound)
	{
		if( lowBound >= highBound)	//잘못된 입력
			return lowBound; 

		float f= rand() % 10000 * 0.0001f;
		
		// [lowBound, highBound) 범위의 float을 리턴한다. 
		return (f * (highBound - lowBound)) +lowBound;
	}

다음 함수는 최소점 min 과 최대점 max로 정의된 상자 내의 임의 벡터를 출력한다.

void d3d: : GetRandomVector(
D3DXVECTOR3* out ,
D3DXVECTOR3* min,
D3DXVECTOR3* max)
out >x GetRandomF10at(min- >x , max- >x) ;
out >y = GetRandomF10at(min->y, max->y);
out->z GetRandomF10at(min->z , max- >z);














*/