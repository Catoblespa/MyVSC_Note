/*

스탠실(stencil) 
    미술-공예 : 물건 모양을 본 든 종이의 그림 부분을 잘라 내어 구멍을 내고,
    이 위에 롤러로 눌러서 그림을 만드는 일 따위.


    스탠실 버퍼는 특수한 효과를 위한 오프 스크린 버퍼로 
    후면 버퍼 및 깊이 버퍼와 동일한 해상도를 가지므로 스텐실 버퍼 내의 ij번째 픽셀은
    후면 버퍼나 깊이 버퍼의 ij픽셀과 대응된다.
    이름이 의미하는 것처럼 스텐실 버퍼는 후면 버퍼의 일저 부분이 렌더링되는 것을 막는 스텐실 효과에 이용된다.

    이 단원에서는 스텐실의 가장 일반적인 활용 예인 거울과 평면 그림자의 구현 방법을 배워본다.


*/

/*
[@]스텐실버퍼 이용하기
    
    스텐실 버퍼를 이용하기 위해서는 먼저 Direct3D를 초기화 하는 시점에
    스텐실 버퍼를 요청해야하며, 이용할 대 이를 활성화 시켜야 한다.
    스텐실 버퍼를 활성화하려면 D3DRS_STENSILENABLE 랜더 상태를 true로 지정하고,
    비활성화 하려면 false로 지정한다.
    스텐실 버퍼를 활성화했다가 다시 비활성화 하는 방법은 다음과 같다.
        Device->SetRenderState(D3DRS_STENCILENABLE, true);
        Device->SetRenderState(D3DRS_STENCILENABLE, false);

    스텐실 버퍼를 디폴트 값으로 되돌리기 위해서는 IDirect3DDevice9::Clear메서드를 이용한다.
    이 메서드는 후면 버퍼와 깊이 버퍼를 소거하는데 이용하던것과 동일한 것이다.

        Device- >Clear(0 , 0 ,
        D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
        0xff000000 , 1.0f, 0 ); 

    함수는 타겟(후면 버퍼) 및 깊이 버퍼와 함께 세번째 인자로 D3DCLEAR_STENCIL
    을 추가하였다. 여섯번째 인자는 스텐실 버퍼를 소거하는 데 이용될 값을 지정하는 것으로
    여기서는 0을 이용하였다.

    [Note! 엔비디아에 따르면 이미 깊이버퍼를 이용하는 상황의 현대 하드 웨어에서는
    스텐실 버퍼 이용에 따르는 비용이 거의 존재하지 않는다고 말한다.]
*/



/*
스텐실 버퍼 요청하기.

    스텐실 버퍼는 깊이 버퍼를 만들때 함께 만들 수 있으며,
    깊이 버퍼의 포맷을 지정할 때 스텐실 버퍼의 포맷도 함께 지정할 수 있다.
    실제로 스텐실 버퍼와 깊이 버퍼는 동일한 오프 스크린 표면 버퍼를 공유하며,
    각 픽셀 내의 메모리 세그먼트만 해당 버퍼로 이용될 분이다.
    세 가지 깊이/스텐실 버퍼 포맷에 대한 설명을 보면 더욱 확실하게 이해 할 수 있다.

    D3DFMT-D24S8   - 32bit 깊이/스텐실 버퍼를 만들어 깊이 버퍼에는 24비트를,
                    스텐실 버퍼에는 픽셀당 8비트를 할당한다.
    D3DFMT_D24X4S4 - 32bit 깊이/스텐실 버퍼를 만들어 깊이 버퍼에는 픽셀당 24비트를,
                    스텐실 버퍼에는 픽셀당 4비트를 할당한다. 나머지 4비트는 이용되지 않는다.            
    D3DFMT_D15S1    - 16bit 깊이/스텐실 버퍼를 만들어 깊이 버퍼에는 픽셀당 15비트 ,
                    스텐실버퍼에는 픽셀당 1비트를 할당한다.

    스텐실 버퍼에 전혀 비트를 할당하지 않는 포맷도 존재한다.
    예를 들어 D3DFMT_D32포맷은 깊이 버퍼에만 32비트를 할당한다.
*/

/*
스텐실 테스트.
    앞서 언급했듯이 후면 버퍼의 일부 영역이 렌더링되는 것을 막는데 스텐실 버퍼를 이용 할 수있다.
    여기에서 특정 픽셀의 렌더링을 막을 것인지의 결정은 다음과 같은 표현식으로 나타낼 수 있는 스텐일 테스트에 의해 내려진다.

    (참조 & 매스크) 비교 연산자 (값 & 매스크)

    스텐실이 활성화되어 있다는 가정 하에 모든 픽셀에 대한 스텐실 테스트가 수행되고,
    이때 두개의 피연산자를 이용한다.
        [1] 왼쪽 피연산자(LHS = 참조 & 매스크) 
        애플리케이션이 정의한 스텐실 참조 값(참조)과 애플레케이션이 정의한 매스크 값(매스크)의 AND 연산으로 얻어진다.
        [2] 오른쪽 피연산자(RHS = 값 & 매스크)
        현재 테스트 하려는 픽셀의 스텐실 버퍼(값)와 애플리케이션이 정의한 매스크 값(매스크)의 AND연산으로 얻어진다.

    이제 '비교 연산자'에 지정된 방법으로 LHS RHS를 비교하는 스텐실 테스트가 수행되며,
    표현식은 결국 (true , false)값으로 평가된다.
    만약 식이 true로 평가되면(통과) 후면 버퍼의 픽셀을 출력하며,
    false로 평가되면(실패) 픽셀이 출력되는 것을 막는다.
    그리고 후면 버퍼에 픽셀이 쓰여지지 않으면 깊이 버퍼에도 또한 쓰여지지 않는다.

*/


/*
스텐실 테스트 제어하기.

    Direct3D는 최대한의 유연성을 제공하기 위해 스텐실 테스트에 이용되는 변수들을
    우리가 제어할 수 있도록 해주고 있다.
    다른말로 하면 스텐실 참조 값과 매스크값, 심지어 비교 연산자까지도 우리가 지정할 수 있다.
    따라서 우리가 직접 스텐실값을 지정하지는 않았지만 스텐실 버퍼에 쓰여질 값에 대한 어느정도 수준제어가
    가능하다.( 스텐실 버퍼를 소거하는 일을 포함하여)


    //스텐실 참조 값
        스텐실 참조 값은 디폴트로 0이지만 D3DRS_STENCILREF 랜더 상태를 이용해 값을 바꿀 수 있다.
        예를 들어 다음의 코드는 스텐실 참조값을 1로 바꾼다.
        
          Device- >SetRenderState(D3DRS_STENCILREF, 0x1);
        
        16진 값을 이용하면 정수의 비트 배열을 확인하는 데 수월하며.   
        AND 등과 같은 비트 연산을 할 때 도움이 된다는 것을 기억하자.


    //스텐실 매스크
    스텐실 매스크 값은 참조와 값 변수 양쪽의 비트를 매스크(감추기)하는데 이용된다.
    디폴트 매스크는 0xffffffff이며 이는 어떤 비트도 매스크하지 않는다는 의미를 가진다.
    D3DRS_STENCILMASK 랜더 상태를 이용하면
    이 매스크 상태를 변경 할 수 있는데,
    예를 들어 다음의 예는 상위 16비트를 매스크한다.
    
        Device->SetRenderState(D3DRS_STENCILMASK, 0x0000ffff); 
        
    [Note!]
    만약 비트와 매스크에 대한 이야기를 전혀 이해할 수 없다면 먼저 
    2진 , 16진 비트 단위 연산등에 대한 자료를 읽어보길 권한다.


    //스탠실 값.
    앞서 언급했듯이 이 값은 스텐실 테스팅을 수행하고 있는 현재 픽셀의 스텐실 버퍼값이다.
    예를 들어 현재 ij번째 픽셀을 테스트하고 있다면 이 값은 스텐실 버퍼의 ij번째 항목이 될 것이다.
    각각의 스텐실 값을 우리가 직접 지정하는 것은 불가능하지만,
    스텐실 버퍼를 소거할 수는 있다.
    또한 부가적으로 스텐실 렌더 상태를 이용하면 스텐실 버퍼로 쓰여질것에 대한 제어가 가능하다.
    스텐실에 관계된 렌더 상태는 조금 뒤에 소개할 것이다.


    //비교 연산자
    D3DTS_STENCILFUNC 랜더 상태를 이용하면 비교 연산자를 지정 할 수 있으며,
    이 비교 연산자로는 D3DCMPFUNC 열거형의 맴버중 하나를 사용한다.

        [1] D3DCMP_NEVER        - 스턴실 테스트가 항상 실패한다
        [2] D3DCMP_LESS         - LHS < RHS 일 경우 스탠실 테스트가 성공한다
        [3] D3DCMP_EQUAL        - LHS = RHS 일 경우 스텐실 테스트가 성공한다
        [4] D3DCMP_LESSEQUAL    - LHS <= RHS 일 경우 스텐실 테스트가 성공한다
        [5] D3DCMP_GREATER      - LHS > RH 일 경우 스텐실 테스트가 성공한다
        [6] D3DCMP_NOTEQUAL     - LHS != RHS 일 경우 스텐실 테스트가 성공한다
        [7] D3DCMP_GREATEREQUAL - LHS >= RHS 일 경우 스텐실 테스트가 성공한다
        [0x7ffffff] D3DCMP_ALWAYS - 스텐실 테스트가 항상 성공한다 

    */
   
/*
 스텐실 버퍼 갱신하기
    특정한 픽셀이 후면 버퍼에 쓰여질지의 여부를 결정하는 것 이외에도 
    다음과 같은 세가지의 가능한 상황에 따라 스텐실 버퍼 항목이 갱신되는 방법을 정의 할 수 있다.

    [] ij번째 픽셀에서 스텐실 테스트가 실패. D3DRS_STENCILFAIL 랜더 상태를 지정하여
    이러한 상황이 발생했을때 스텐실 버퍼 내의 ij번째 항목을 갱신하는 벙법을 정의 할 수 있다.
        Device->SetRenderState(D3DRS_STENCILFAIL, StencilOperation);

    [] ij번째 픽셀에서 깊이 테스트가 실패, D3DRS_STENCILZFAIL 랜더 상태를 지정하여
    이러한 상황이 발생 했을때 ij번째 항목을 갱신하는 방법을 정의 할 수 있다.
         Device->SetRenderState(D3DRS_STENCILZFAIL, StencilOperation); 

         여기서 StencilOperation 값으로는 다음 상수중 하나를 넣는다.
                    
            [1] D3DSTENCILOP KEEP 스텐실 버퍼 항목을 번경하지 않도록 지정한다 즉， 현재의 값을 그대로
            유지한다)

            [2] D3DSTENCILOP ZERO       - 스텐실 버퍼 항목을 으로 지정한다
            [3] D3DSTENCILOP REPLACE    - 스텐실 버퍼 항목을 스텐실 참조 값으로 대체하도록 지정한다
            [4] D3DSTENCILOP INCRSAT    - 스탠실 버퍼 항목을 증가시키도록 지정한다. 만약 증가된 값이 허
                                        용 최대 값을 넘을 경우， 해당 항목을 최대치로 고정한다.
            [5] D3DSTENCILOP DECRSAT    -  스텐실 버퍼 항목을 감소시키도록 지정한다 만약 감소된 값이 보
                                            다 작을 경우 해당 항목을 으로 고정한다
            [6] D3DSTENCILOP INVERT     - 스텐실 버퍼 항목을 반전시키도록 지정한다
            [7]D3DSTENCILOP INCR        - 스텐실 버퍼 항목을 증가시키도록 지정한다 만약 증가된 값이 허용 최
                                            대 값을 넘을 경우， 으로 돌려진다
            [8]D3DSTENCILOP DECR        - 스텐실 버퍼 항목을 감소시키도록 지정한다 만약 감소된 값이 보다
                                            작을 경우 허용 최대 값으로 려진다，

*/

/*
스텐실 쓰기 매스크
    
    언급한 스텐실 렌더 상태 이외에도 스텐실 버퍼에 쓰여지는 모든 값을 매스크하는 쓰기 매스크를 설정할 수 있다.
    쓰기 매스크의 디폴트 값은 0xffffffff이며 D3DRS_STENCILWRITHEMASK 랜더 상태를 이용하면 쓰기 매스크를 지정할 수 있다.
    다음은 코드 상위 16비트를 매스크하는 예시다.
        Device->SetRenderState(D3DRS STENCILWRITEMASK, 0x0000ffff);
        
*/
