
/*
    
    
----------
백터의 크기
----------
D3DXVec3Lenght(const D3DXVECTOR3 * pV); 
    백터의 크기를 계산하여 리턴한다.
    D3DXVECTOR3 v(1.0f , 2.0f, 3.0f);
    flaot magnitude = sD3DXVec3Lenght(&v) ;  // = sqrt(14)



----------
백터의 정규화
----------
    백터의 정규화는 백터의 크기를 1로 만들어 단우백터가 되도록 하는 것이다.
    벡터의 각 성분을 벡터의 크기로 나누면 정규화가 된다.
D3DXVec3Normalize(D3DXVECTOR3 * pOut , const D3DXVECTOR3 *pV);
    이 함수는 결과를 가리키는 포인터를 리턴하므로 이를 다른 함수의 인자로 전달 할 수 있다.
    D3DX 수학 함수는 대부분의 경우 특별히 언급하지 않는 한 결과를 가리키는 포인터를 리턴한다.


----------
백터의 더하기, 빼기
----------
    대응되는 성분을 더하면 두개의 벡터를 더할 수 있다.
    더하고자 하는 벡터는 반드시 동일한 차원을 가져야한다.
Vector3 u (2.0f, 0.0f, 1.0f);
Vector3 v (0.0f, -1.0f, 5.0f);
Vector3 sum = u+v; // = (2.0f,-1.0f,6.0f);

    더하기와 비슷하게 벡터의 대응되는 성분을 빼는 방법으로 벡터의 빼기를 수행 할 수있다.
Vector3 difference = u-v; // = ((2.0f, 1.0f, -4.0f);
    백터의 빼기는 v의 머리에서 u의 머리까지의 벡터를 리턴한다.
    만약 u 와 v의 성분을 포인트로 좌표를 생각한다면, 백터 빼기를 이용해
    한 포인트에서 다른 포인트까지의 벡터를 얻을 수 있다.
    포인트 간의 방향을 기술하는 벡터를 얻어야 하는 경우가 많기 때문에 벡터 빼기는 상당히 유용한 작업이다.


----------
스칼라 곱
----------  
    백터는 스칼라로 곱하는 것이 가능하며, 짐작할 수 있겠지만 이를 통해 벡터의 배율이 변경된다.
    음수로 곱을 수행하지 않는 이상 백터의 방향은 변하지 않으며,
    음수를 이용하는 경우에는 벡터의 방향이 반전된다.
    D3DXVECTOR3 u(1.0f , 1.0f, -1.0f) ;
    D3DXVECTOR3 scaledVec = u * 10.0f; // = (10.f, 10.f, -10.f);


----------
백터의 내적
---------- 
    내적은 벡터 대수학에서 정의하는 두 가지 곱셈중 하나이며 다음과 같이 계산된다.
    U dot V   Ux * Vx + Uy * Vy + Uz * Vz = S
    위의 식은 분명한 기하학적 의미를 보여주고 있지 않다.
    코사인 법칙을 이용하면 U dot V = ||U|| * ||V||의 관계를 발견할 수 있으며,
    이는 두 벡터 간의 내적이 [벡터 크기배율을 가진 벡터 간 각도의 코사인]임을 알 수 있다.
    따라서 U와 V가 모두 단위 벡터일 경우 U dot V는 두 벡터 간의 각도의 코사인이 된다.

    다음은 내적의 몇가지 특성을 정리한 것이다
    1. U dot V = 0 일때, U와 V는 직각이다.
    2. U dot V > 0 일때 두벡터간의 각도θ는 90보다 작다.
    3. U dot V < 0 일때 두벡터간의 각도θ는 90보다 크다.

    다음의 D3DX 함수를 이용하면 두 벡터 간의 내적을 계산 할수 있다.
    
D3DXVec3Dot(const D3DXVECTOR3* pV1 , const D3DXVECTOR3* pV2);

D3DXVECTOR3 u(1.0f, -1.0f, 0.0f); 
D3DXVECTOR3 v(3.0f, 2.0f, 1.0f);

//1.0* 3.0 + -1.0 * 2.0 + 0.0 * 1.0
// = 3.0- 2.0  
float  dot = D3DXVec3Dot(&u , &v)// = 1.0f
    
    


----------
백터의 외적
---------- 
    벡터 수학이 정의하는 두번째 형식의 곱은 외적이다.
    스칼라로 계산되는 내적과는 달리 외적은 다른 벡터로 계산되는데, U와 V 두벡터의 외적을 수행하면
    다른 벡터인 p를 얻으며 이는 u와 v에 서로 직각을 이룬다.
    즉, P는 U에 직각이며, P는 V에 직각이다.
    외적은 다음과 같이 계산한다.

    (cross)
P = u * v = [(Uy*Vz - Uz*Vy), (Uz*Vx - Ux*Vz) , (Ux*Vy - Uy*Vx)]
다음은 성분 형식이다.
Px = Uy*Vz - Uz, Vy
Py = UzVx - UxVz
Pz = UxVy - UyVx

    다음은 D3DX 함수를 이용하면 두 벡터 간의 외적을 계산할 수 있다.
D3DXVec3Cross(D3DXVECTOR3* pOut , const D3DXVECTOR3* pV1 , const D3DXVECOTR3* pV2);
    
    U와 V벡터를 외적해서 얻은 P벡터의 스칼라 음의 곱 (-P) 또한 U와 V에 서로 직각임을 알 수 있다.
    외적을 수행하는 순서는 우리가 얻을 결과가 P나 -P중 어떤것이 될지를 결정한다.
    다른 말로는 U*V = -(V*U)이다.
    이는 외적이 교환적이지 않다는것을 보여주는 것이다.
    외적으로 리턴되는 벡터는 왼손 엄지 규칙을 이용해 알아낼 수 있는데,
    만약 왼손 첫번째 백터 방향의 손가락을 두번째 벡터 방향으로 구부리면,
    엄지 손가락은 리턴되는 벡터의 방향을 가리킨다.


    */