#include <iostream>


using namespace std;


// 팩토리얼
int Factorial(int n)
{
	if (n <= 1)
	{
		return 1;
	}
	else
	{
		return n*Factorial((n - 1));
	}
}


//인라인 함수.
//인라인 함수는 함수명으로 호출 될때 해당 라인에 함수의 내용을 대입하는 형식을 사용한다.
//일반 함수의 경우 함수를 호출하기 위해 메모리를 잡고 인수 스택을 잡는 대에 비하여, 인라인은 해당라인을 치환하는 방법을 사용한다.
//일반 함수를 사용하면 속도면에서는 느리지만, 프로그램의 크기는 절약 할 수 있다.
//인라인 함수를 사용하면 속도는 빠르지만, 프로그램의 크기가 커질 수 있다.

//위와 같은 특징 때문에 인라인 함수는 본체 코드가 아주 작고, 속도가 중요할때 사용한다.
//러 모듈에서 공유하는 함수라면 헤더 파일에 작성해야 한다. 
//인라인 함수의 본체는 정의가 아닌 선언이므로 메모리를 소모하지도 않으며 중복 선언해도 상관없으므로 보통 헤더 파일에 작성한다.
//단 같은 모듈에서 두 번 선언하는 것은 안된다.

//프로그래머가 함수 선언앞에 inline 키워드를 붙이더라도 컴파일러는 이 지정을 무시하고 일반 함수로 만들어 버릴 수도 있다. 
//프로그래머가 inline 키워드를 사용하는 것은 이 함수가 인라인이 되었으면 좋겠다는 희망 사항일 뿐이며 컴파일러는 조건이 맞지 않을 경우 이 지정을 무시할 수 있다. 
//마치 register 기억 부류와 유사하다.

////반대로 inline 키워드를 명시적으로 쓰지 않아도 자동으로 인라인 함수가 되는 경우도 있는데 클래스 선언에 코드가 작성되어 있는 멤버 함수는 자동 인라인 속성을 가진다.
/*
인라인 함수는 매크로 함수에 비해 다음과 같은 추가적인 이점이 있다.

① 인라인 함수는 타입을 인식한다.매크로 함수가 전달된 인수를 기계적으로 단순히 치환하는 것과는 비교된다.
그래서 잘못된 타입을 전달함으로써 발생할 수 있는 민감한 에러 처리에 유리하며 또한 컴파일러의 산술 변환 서비스를 받을 수 있다.

② 인라인 함수는 함수의 형태를 띄고 있기 때문에 필요할 경우 지역변수를 사용할 수 있다.
매크로도 블록 변수 형태로 지역변수를 사용할 수는 있지만 일반적이지는 않다.
그래서 인라인 함수가 매크로 함수보다는 조금 더 복잡한 동작을 정의할 수 있다.

③ 매크로는 컴파일 이전 단계인 전처리 단계에서 기계적으로 인수를 치환하기 때문에 괄호를 싸지 않으면 예상치 못한 부작용의 위험이 높다.
뿐만 아니라 매크로의 인수에 ++ 연산자나 += 연산자를 사용하는 것은 여러 모로 위험한 면이 있는데 
이런 단점에 대해서는 이미 경험해 본 바가 있다.

인라인 함수는 값에 의한 인수 전달, 연산자의 우선 순위와 결합 법칙의 적용을 받기 때문에 이런 위험이 없다.
*/


inline int randfunc(int n)
{
	return rand() % n;
}


int main()
{
	cout << "1~5까지의 곱" << Factorial(5) << endl;
	return 0;
}