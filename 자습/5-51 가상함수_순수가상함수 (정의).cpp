#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <math.h>

using namespace std;
/*
추상 클래스의 예
http://soen.kr/lecture/ccpp/cpp3/30-3-2.htm

추상클래스가 쓰인 예시 - 유닛 추상 클래스 스타크래프트 1
http://soen.kr/lecture/ccpp/cpp3/30-3-3.htm


*/


/*
가상 함수는 파생 클래스가 안전하게 재정의할 수 있는 함수이다.
만약 상속 관계가 아니라면 가상 함수를 선언할 필요가 없으므로 가상 함수는 상속 계층내에서만 의미가 있으며 
파생 클래스에게 재정의 기회를 주기 위해 존재하는 것이라고 할 수 있다.

러나 가상 함수를 반드시 재정의해야만 하는 것은 아니다. 기반 클래스의 동작을 그대로 쓰고 싶으면 단순히 상속만 받고 변경할 필요가 있을 때만 재정의하면 된다.

기반 클래스가 가상 함수를 만드는 이유는 혹시라도 재정의하고 포인터로 호출할 때를 대비한 것이다. 
가상 함수는 재정의해도 되는 함수이지 반드시 재정의해야 하는 함수는 아니다.

이에 비해 순수 가상 함수(Pure Virtual Function)는 파생 클래스에서 반드시 재정의해야 하는 함수이다.
순수 가상 함수는 일반적으로 함수의 동작을 정의하는 본체를 가지지 않으며 따라서 이 상태에서는 호출할 수 없다.
본체가 없다는 뜻으로 함수 선언부의 끝에 =0이라는 표기를 하는데 이는 함수만 있고 코드는 비어 있다는 뜻이다. 다음 예제를 통해 순수 가상 함수의 정의를 연구해 보자.
*/


class Graphic
{
public:
	 virtual void Draw() = 0;			//Draw 함수가 순수 가상 함수로 선언되어 있다.
										//이처럼 하나 이상의 순수 가상 함수를 가지는 클래스를 추상 클래스(Abstract Class)라고 한다. 
};										//추상 클래스는 동작이 정의되지 않은 멤버 함수를 가지고 있기 때문에 이 상태로는 인스턴스를 생성할 수 없다. 
										//이 예제에서 Graphic G 선언문의 주석을 풀어 보면 순수 가상 함수가 있어 인스턴스를 만들 수 없다는 에러가 발생할 것이다.

//추상 클래스인 Graphic은 도형이라는 너무 일반적인 대상을 표현하기 때문에 그리기와 관련된 어떠한 정보도 가질 수 없으며 따라서 동작도 정의할 수 없다. 
//그러다 보니 이런 타입의 객체를 생성하는 것은 아무 의미가 없는 것이다.

//그렇다면 객체를 만들지도 못하는 추상 클래스는 도대체 왜 정의하는 것일까? 
//추상 클래스는 Line, Circle, Rect 구체 클래스의 공동의 조상이 되어 이 객체들의 집합을 관리하기 위해 필요하다.

//추상 클래스의 객체를 생성할 수는 없지만 추상 클래스 타입의 포인터를 선언할 수는 있다. 
//그래서 Graphic *의 배열을 선언하면 이 배열로 Graphic 파생 클래스의 객체 집합을 관리할 수 있다
//Graphic 파생 클래스들을 집합적으로 관리 하기 위해서 비록 객체를 생성할 수 없는 추상 클래스라도 상징적인 공동의 조상이 필요한 것이다.
//만약 여기서 이전 예제 처럼 Move함수를 순수 가상함수로 추가 할경우 당연히 파생클래스 에서도 Move함수를 재정의 해야한다.
// 그렇지 않으면 파생클래스들은 추상클래스가 되고, 인스턴스를 생성 할 수 없다.

//****  이때 추상 클래스가 정의하는 기능 목록을 인터페이스라고 한다.  ****
//이 예제의 Graphic 추상 클래스는 개발자에게 "도형이 되기 위해서는 적어도 이 정도의 기능은 꼭 필요하다"라는 것을 강제하고 있는 것이다.

// 순수가상함수는 보통 파생클래스에게 함수를 재정의 하기위해 쓰지만, 몸체를 갖지 못한는 것은 아니다.
// 파생클래스들의 함수가 공통적으로 기능하기 바라는 기능이 있다면 몸체를 사용할 수 있다.
// Graphic 클래스의 순수 가상함수를   virtual void Draw()=0 { clrscr(); } 로 수정하게되면					//clrscr() : 화면을 지우는 명령
//파생클래스에서 Graphic::Draw()를 써서 호출할 수 있다.

//이렇게 몸체를 가지더라도 순수가상함수의 의미인 =0이 붙어 있으면 여전히 추상클래스다. 여전히 인스턴스는 생성하지 못한다.







class Line : public Graphic				// 추상 클래스 Graphic를 이용해 만든 구체 클래스, 지금까지 만들어왔던 모든 클래스가 구체 클래스다.
{
public:
	virtual void Draw() { puts("선을 긋습니다."); }

};



class Circle : public Graphic
{
public:
	virtual void Draw() { puts("동그라미 그렸다 치고."); }

};



class Rect : public Graphic
{
public:
	virtual void Draw() { puts("요건 사각형입니다."); }

};


int main()
{

	Graphic* pG[3];
	int i;

	//  Graphic G;				// 순수 가상함수를 이용하여 인스턴스를 만들려고 하면 에러에러!!

	pG[0] = new Line;
	pG[1] = new Circle;
	pG[2] = new Rect;



	for (i = 0; i < 3; i++)
	{
		pG[i]->Draw();

	}



	for (i = 0; i < 3; i++) 
	{
		delete pG[i];
	}
	return 0;
}