#include <iostream>
#include <string.h>
#include <memory>
using namespace std;

/*
C++의 클래스는 파괴자라는 특별한 함수를 가지는데 이 함수는 객체가 파괴될 때 자동으로 호출된다.
그래서 객체가 동적으로 메모리를 할당하거나 시스템 자원을 사용하더라도
파괴자에 정리 코드를 작성해 놓으면 별도의 조치가 없더라도 객체가 사라질 때 해제 작업을 하도록 되어 있다.

앞 절에서 연구해 본 string 클래스를 생각해 보면 파괴자가 얼마나 편리한가를 알 수 있다. 
string 객체는 가변 길이의 문자열을 저장하기 위해 버퍼를 동적으로 할당해서 관리하는데 개발자가 신경쓰지 않아도 이 메모리는 자동으로 회수된다.

 이런 면을 보면 파괴자는 역시 편리한 함수이다. 
 그러나 파괴자는 스택에 정적으로 할당된 객체에 대해서만 동작하며 동적으로 할당한 메모리에 대해서는 책임지지 않는 문제점이 있다. 
 
*/
int main()
{
	double* rate;

	rate = new double;
	*rate = 3.1415;
	cout << *rate << endl;

	// delete rate;
	//실수형 변수를 가리키는 rate 포인터를 선언하고 이 포인터에 실수형의 길이만큼 동적 할당하여 그 번지를 저장했다.
	//이렇게 되면* rate는 실수형 변수가 되므로 동적으로 할당된 메모리를 실수형 변수처럼 사용할 수 있다.
	//rate는 이 함수의 지역변수이므로 함수가 종료될 때 자동으로 해제된다.
	//그러나 rate가 가리키는 메모리는 자동으로 해제되지 않는데 동적으로 할당했다는 것은 필요할 때까지 쓰겠다는 의사 표현이므로 
	//직접 해제하기 전까지는 힙에 계속 남아 있는다.

	//메모리 관리 원칙에 의해 한 번 할당한 메모리는 해제할 때까지 다른 용도로 재사용되지 않으므로 명시적으로 delete를 호출해야만 해제된다.


	// auto_ptr은 동적으로 할당된 메모리도 자동으로 해제하는 기능을 가지는 포인터의 래퍼 클래스이다.
	//auto_ptr의 파괴자에 포인터 해제 코드를 작성하면 어떤 경우라도 안전한 해제를 보장할 수 있다.
	

	//template<typename T> class auto_ptr
	auto_ptr<double> rate2(new double);	//auto_ptr<double> 타입의 객체 rate를 선언하되 새로운 double형 변수를 동적 할당하여 생성자로 전달
	*rate2 = 3.1415;

	cout << *rate2 << endl;
	//uto_ptr은 이 포인터를 내부 멤버 변수에 저장해 놓고 *, ->, = 등 포인터에 사용하는 대부분의 연산자를 오버로딩하여 
	//이 객체에 대한 모든 연산을 내부 포인터에 대한 연산으로 중계하는 역할을 한다. 
	//그래서 rate를 마치 double형의 포인터인 것처럼 사용할 수 있다. 
	//rate객체에 *연산자를 적용하면 동적으로 할당된 메모리에 대해 *연산자가 적용되어 이 값을 읽거나 변경할 수 있다. 
	//래퍼이므로 래핑한 대상을 그대로 흉내내는 것이다.

	//rate의 파괴자에서는 delete를 자동으로 호출하므로 함수가 끝날 때 rate를 해제할 필요가 없으며 해제되지도 않는다. 
	//파괴자가 없지만 auto_ptr은 클래스이므로 함수가 끝날때 파괴자가 호출된다.


	//이렇게 string형에도 사용 가능하다.
	auto_ptr<string> pStr(new string("AutoPtr Test"));

	cout << *pStr << endl;



	return 0;
}