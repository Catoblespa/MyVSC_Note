#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <math.h>

using namespace std;


/*
같은 템플릿으로부터 만들어진 함수는 타입만 제외하고 동일한 본체를 가지므로 동작도 동일하다.
만약 특정 타입에 대해서만 다르게 동작하도록 하고 싶다면 이때는 특수화(Specialization)라는 기법을 사용한다. 
예를 들어 Swap 함수를 실수에 대해 적용할 때는 값을 전부 교환하지 말고 정수부만 교환하고 싶다고 하자. 
이럴 때는 double 형에 대해서 특수한 함수를 하나 만들면 된다.
*/


template <class T>
void Swap(T& a, T& b)
{
	T t;
	t = a; a = b; b = t;
}

template <> 
void Swap<double>(double& a, double& b)
{
	int i, j;
	i = (int)a;
	j = (int)b;
	a = a - i + j;
	b = b - j + i;

}




int main()
{

	double a = 1.2, b = 3.4;

	printf("before a=%g, b=%g\n", a, b);

	Swap(a, b);

	printf("after a=%g, b=%g\n", a, b);



	return 0;	
}
//Swap 함수 템플릿을 정의해 두고 double형에 대해서 특별한 Swap 함수를 따로 정의했다. 
//double에 대해 특수화된 Swap 함수의 본체는 정수부만 교환하는 고유한 코드를 가진다.
//main 에서는 두 개의 실수를 Swap 함수로 교환했는데 실행 결과는 다음과 같다.
/*
		before a=1.2, b=3.4
		after a=3.2, b=1.4
*/

//만약 double에 대한 특수화를 하지 않으면 일반적인 Swap 함수가 호출되어 소수부, 실수부가 같이 바뀔 것이다.

//컴파일러는 템플릿 함수 호출 구문이 있을 때 항상 템플릿의 정의보다 특수화된 정의에 우선권을 주므로 
//동일한 이름의 템플릿과 특수화 함수가 존재하면 특수화된 함수가 호출된다.특수화 함수를 표기하는 방법은 여러 가지가 있다.


//① template <> void Swap<double>(double& a, double& b)
//② template <> void Swap<>(double& a, double& b)
//③ template <> void Swap(double& a, double& b)
//④ void Swap<double>(double& a, double& b)
//⑤ void Swap<>(double& a, double& b)
//⑥ void Swap(double& a, double& b)  No!!

//특수화된 함수라는 것을 표시하기 위해 template <> 로 시작하는데 <>가 없으면 명시적 구체화 구문이 되므로 잘 구분해야 한다.
//1.함수 이름 뒤에는 어떤 타입에 대한 특수화 함수인지 <> 괄호와 특수화된 타입 이름을 밝힌다
//2.①번 표기법이 가장 완전한 형태이되 좀 더 간략한 표기법도 쓸 수 있다. 
		//어떤 타입에 대해 특수화되었는지는 어차피 인수의 타입으로도 알 수 있으므로 함수명 다음의 <> 괄호는 생략 가능하며 
		//<>만 남겨 두고 타입만 생략하는 것도 가능하다. 
		//단, 템플릿 인수가 리턴 타입이나 내부 지역변수로 사용될 때는 ①번 타입만 가능하다.

//3.또한 ④번처럼 함수명 다음에 <> 괄호가 있다면 이 표기로부터 함수 템플릿에 대한 특수화 함수라는 것을 알 수 있으므로 앞쪽의 template <> 도 생략 가능하다.
		//아직까지도 이 표기법을 지원하고는 있지만 최신 표준에는 이 표기법이 인정되지 않으므로 가급적 사용을 자재해야 한다.

//4.마지막 ⑥번 형식은 특수화 함수가 아니라 그냥 일반 함수 Swap을 정의하는 것이다. 
//이렇게 일반 함수를 정의해도 일단은 목적을 이룰 수 있지만 우선 순위의 문제가 있어 바람직하지 않다. 



// 특수화 함수를 표기하는 방법이 왜 이렇게 많은가 하면 템플릿이라는 기능이 처음부터 표준에 의해 정립된 것이 아니라
// 각 컴파일러 제작사들에 의해 비공식적으로 발전해 오다가 비교적 최근에 표준으로 채택되었기 때문이다. 
// 이전에 사용하던 형식을 무시할 수는 없기 때문에 이런 많은 표기법들이 난무하는 상황이 되었는데 이런 면을 보면 표준이 얼마나 중요한가를 알 수 있다.