#include <iostream>
#include <time.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include <functional>		

using namespace std;


/*
  ///반복자의 기능
  에서 반복자의 기본적인 기능에 대해 소개했는데 그 중 가장 기본적인 것은 컨테이너의 한 요소를 가리키는 포인터의 역할이다. 
  처리 대상을 지정하거나 검색 결과를 리턴하며 두 개씩 짝을 이루어 구간을 지정하기도 한다. 
  이외에 가리키는 요소를 읽어오는 * 연산자, 앞뒤 요소로 이동할 수 있는 ++, -- 연산자를 제공하며 임의 위치로 이동하거나 반복자끼리 비교 및 대입도 가능하다.

  그러나 모든 반복자가 이런 기능들을 한꺼번에 가지는 것은 아니며 어떤 연산이 제공되는가에 따라 다음과 같이 분류할 수 있다. 
  STL은 제공하는 기능에 따라 반복자를 다섯 레벨로 분류하는데 아래쪽으로 내려갈수록 더 많은 기능을 제공한다. 
  이 절에서 각 반복자 종류들의 기능을 순서대로 살펴 볼 예정이므로 도표를 통해 이름부터 파악해 놓자.
  //================================================================================================================
/// 반복자		약어			설명														원어
	입력		InIt		오로지 입력만 가능하며 쓸 수는 없다.						input_iterator_tag

	출력		OutIt		출력만 가능하며 읽지는 못한다.								output_iterator_tag

	순방향		FwdIt		입출력이 모두 가능하다. 전진만 가능하다.					forward_iterator_tag

	양방향		BiIt		앞뒤로 이동할 수 있다. 감소 연산자를 정의한다.				bidirectional_iterator_tag

	임의 접근	RanIt		임의의 요소를 참조할 수 있다. [ ] 연산자를 정의한다.		random_access_iterator_tag

																					contiguous_iterator_tag  ???
//================================================================================================================


STL이 반복자를 기능별로 분류하는 이유는 알고리즘의 적용 조건을 제한하기 위해서이다. 
알고리즘은 내부 구현을 위해 반복자의 여러 기능을 활용하는데 어떤 기능이 사용되는가에 따라 요구되는 반복자가 다르다. 
만약 해당 반복자가 알고리즘이 요구하는 기능을 제공하지 못한다면 이 반복자로는 그 알고리즘을 호출할 수 없다.

예를 들어 요소들을 정렬하는 sort 함수는 효율적인 정렬을 위해 임의 접근이 가능해야 하는데 임의 접근이 지원되지 않는 반복자에 대해서는 이 기능을 사용할 수 없다.

알고리즘 함수들은 모두 함수 템플릿으로 정의되어 있으며 반복자 타입을 템플릿 인수로 받아들인다. 
각 알고리즘의 원형에는 반복자에 대한 최소한의 요구 사항이 명시되어 있으므로 원형을 보면 어떤 반복자가 필요한지 쉽게 알 수 있다. 
find와 sort 알고리즘의 원형을 다시 한 번 더 보자.

		//InIt find(InIt first, InIt last, const T& val);
		//void sort(RanIt first, RanIt last);

find는 검색 중에 값을 읽기만 하고 순차적으로 값을 점검하므로 입력 반복자를 요구한다. 원형의 first, last에 InIt라는 반복자 타입이 분명히 명시되어 있다.
sort의 원형에는 RanIt 반복자 타입이 명시되어 있으므로 이 함수로 정렬을 하려면 임의 접근 반복자를 제공해야 한다.
	즉. 임의 접근 반복자는 입력 반복자의 모든 기능을 지원하므로 find 알고리즘에도 당연히 사용할 수 있다.
*/


int main()
{

	return 0;
}


/*






*/